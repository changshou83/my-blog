# 内容

:::tip
未整理完
:::

## 作用

- 当响应式对象的值被改变时，副作用函数被自动执行
- 声明式的开发体验

## 实现

- 流程
  - 读取操作发生时，将副作用函数放入桶中
  - 设置操作发生时，取出副作用函数并执行
- 完善细节
  - [[注册副函数]]
  - 设计‘桶’的结构
    - [[设计‘桶’的结构#结构示意]]
    - [[设计‘桶’的结构#操作封装]]
- 分支切换
  - [[分支切换#问题]]
  - [[分支切换#定义]]
  - [[分支切换#思路]]
- 嵌套 effect
  - [[effect栈#问题]]
  - [[effect栈#原因]]
  - [[effect栈#解决]]
- 自增导致的死循环问题
  - [[自增循环问题#原因]]
  - [[自增循环问题#解决]]
-
- computed
- watch

## 方案

### 非原始值

### 原始值

- 原始值按值传递
- Proxy 无法代理原始值，所以需要包一层 ref 变成响应式数据

#### ref

- 接受原始值，将其包裹进一个对象(wrapper)，然后用 reactive 使其变成响应式对象
- 为了区分 ref 和 reactive，为 wrapper 添加一个不可枚举，不可写的属性

#### 解决响应式丢失问题

- What?`newObject={ ...ReactiveObj }`使 newObj 中的值丢失响应性
- Why?其实是读取源对象的值复制给新对象而已，监听的是对象不是值
- How?给 reactiveObj 中的值套一层访问代理(所以其实还是访问 ReactiveObj 中的值)

#### 自动脱 ref

在模板中使用 ref 时，setup 会将返回值传给一个代理对象，这个代理对象会在获取和设置对象值时根据标识判断是否为 ref，从而进行不同的操作。

## 小结

- 基本实现原理：对‘读取’和‘设置’的拦截，在副作用函数与数据之间建立联系。读取时，将副作用函数存入桶中；设置时，取出副作用函数并执行。
- 完善：副作用函数注册；'桶'结构优化；
