# HTTP缓存

- 存储与请求关联的响应，并将存储的响应复用于后续请求
- 优点
	- 客户端和缓存越近，响应速度就越快
	- 源服务器不需要处理请求
- 不同类型
	- 私有缓存
		- 是绑定到特定客户端的缓存——通常是浏览器缓存。可以存储客制化需求
		- `Cache-Control: private`
		- 请注意，如果响应具有 `Authorization` 标头，则不能将其存储在私有缓存
	- 共享缓存
		- 代理缓存(慢慢过时)
			- 通常不由服务开发人员管理
			- 随着 HTTPS 变得越来越普遍，客户端/服务器通信变得加密，在许多情况下，路径中的代理缓存只能传输响应而不能充当缓存
		- 托管缓存
			- 由服务开发人员明确部署，以降低源服务器负载并有效地交付内容
			- 包括反向代理、CDN 和 service worker 与缓存 API 的组合
- 启发式缓存
	- 即使没有给出 `Cache-Control`，如果满足某些条件(例如长时间未更新)，响应也会被存储和重用。这称为**启发式缓存**
	- 启发式缓存是在 `Cache-Control` 被广泛采用之前出现的一种解决方法
- 基于age的缓存策略
	- 存储的 HTTP 响应有两种状态：**fresh** 和 **stale**
		- _fresh_ 状态通常表示响应仍然有效，可以重复使用
		- _stale_ 状态表示缓存的响应已经过期
		- 确定响应何时是 fresh 的和何时是 stale 的标准是 **age**
	- 规定一个max-age，如果age大于max-age则过期，否则有效
	- 在 HTTP/1.0 中，新鲜度过去由 `Expires` 标头指定
- Vary响应
	- 区别响应本市上是基于URL
	- 也可以通过Vary指定其他区分的依据(例如Accept-Language)
- 验证响应
	- 过时的响应不会立即被丢弃，浏览器通过询问源服务器将陈旧的响应转换为新的响应，这叫验证
	- 通过使用包含 `If-Modified-Since` 或 `If-None-Match` 请求标头的**条件请求**完成的
	- `If-Modified-Since`
		- 通过`Last-Modified`请求头标识上次修改的时间
		- 服务器通过Last-Modified判断资源自指定时间是否更新
			- 如果未更新，则返回304(Not Modified)，客户端接收到304后，将更新旧响应的状态
			- 否则，返回新的资源
		- 问题
			- 时间格式复杂且难以解析
			- 分布式服务器难以同步文件更新时间
	- `ETag/If-None-Match`
		- `ETag` 响应头的值是服务器生成的任意值
		- 如果响应是旧的
			- 客户端会将etag放入if-none-match请求头，询问资源是否被修改
			- 如果服务器判断etag与if-none-match相同，则返回304请求；否则，返回200与新资源
	- 如何使用etag和last-modified
		- 在缓存重新验证期间，如果 `ETag` 和 `Last-Modified` 都存在，则 `ETag` 优先
		- `Last-Modified` 不仅仅对缓存有用
		- 最好同时提供 `ETag` 和 `Last-Modified`
	- 强制更新
		- 不希望重复使用响应，而是希望始终从服务器获取最新内容
		- 通过在响应中添加 `Cache-Control: no-cache` 以及 `Last-Modified` 和 `ETag`进行强制验证
- 不使用缓存
	- `no-cache` 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应，在验证后可重用
	- 可能的原因
		- 不与其他用户共享
			- 在这种情况下，即使设置了 `no-store`，也必须设置 `private`
		- 希望始终提供最新信息
		- 兼容过时的实现
- 重新加载
	- 请求通过 `If-None-Match` 和 `If-Modified-Since` 进行验证
	- 避免重新验证：`Cache-Control: max-age=31536000, immutable`
- 删除缓存
	- 基本上没有办法删除用很长的 `max-age` 存储的响应
	- 缓存减少了对服务器的访问，这意味着服务器失去了对该 URL 的控制
	- 如果服务器不想失去对 URL 的控制——例如，在资源被频繁更新的情况下——你应该添加 `no-cache`
- 常见的缓存模式
	- 默认设置
		- 为确保默认情况下始终传输最新版本的资源，通常的做法是`Cache-Control: no-cache`
		- 如果要保证内容个性化：`Cache-Control:nocache,private`
	- 缓存破坏
		- 一种通过在内容更改时更改 URL 来使响应在很长一段时间内可缓存的技术
		- 最适合缓存的资源是静态不可变文件，其内容永远不会改变
		- 对于会变化的资源，通常的最佳实践是每次内容变化时都改变URL，这样URL单元可以被缓存更长的时间,例如在URL中添加一个hash值
		- 常见组合
			- `Cache-Control:public,max-age=...,immutable`
			- `Last-Modified:...`
			- `ETag:...`
	- 主资源
		- 与子资源不同，主资源不能使用缓存破坏，因为它们的 URL 不能像子资源 URL 一样被修饰。例如HTML文件，favicon.ico等
		- 但是可以使用托管缓存来实现对主要资源的缓存，因为可以通过API删除CDN上的缓存来实现主要资源的更新

## 重点

- 什么是HTTP缓存及其优点
- HTTP缓存的类型
- 基于age的缓存策略
- 缓存的验证
- 缓存破坏
