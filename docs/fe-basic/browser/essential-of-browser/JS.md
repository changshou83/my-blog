# JS

## 变量提升

- JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译
- 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined
- 在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数
- 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的

## 调用栈

- 调用栈就是用来管理函数调用关系的一种数据结构
- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码
- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶
- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈
- 当分配的调用栈空间被占满时或者达到最大调用深度时，就会引发“堆栈溢出”问题

## 块级作用域

- 由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题
- 在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域
	- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
	- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
- 新的块级作用域
	- let和const定义的变量都支持块级作用域(`{ ... }`)

## 作用域链和闭包

- 把通过作用域查找变量的链条称为作用域链。作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构
- 闭包是一个函数及其所依赖的状态的组合

## this对象

- this是在运行时从词法作用域传入的函数参数，argument也是
- 当函数作为对象的方法调用时，函数中的 this 就是该对象
- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window
- 嵌套函数中的 this 不会继承外层函数的 this 值
- 因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this
